{"version":3,"sources":["map/tiles.ts","map/layer.ts","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["parser","require","loadTiles","event","center","target","getCenter","zoom","Math","trunc","getZoom","lat","lng","latitude","clip","longitude","x","pow","y","log","tan","PI","cos","input","minValue","maxValue","min","max","getTileCoords","console","this","map","state","tilesLoaded","includes","push","fetch","floor","mapboxgl","accessToken","then","res","a","ok","arrayBuffer","data","tile","VectorTile","Protobuf","buildings","concat","Array","layers","building","length","fill","el","index","feature","toGeoJSON","drawBuilings","apply","catch","message","filter","forEach","properties","type","drawn","lnglat","geometry","coordinates","pos","MercatorCoordinate","fromLngLat","mercatorOffset","origin","scale","height","CylinderGeometry","material","MeshPhongMaterial","color","specular","emissive","obj","Mesh","position","set","rotation","scene","add","id","originLat","originLng","animate","cylinder","changePerInterval","requestAnimationFrame","App","useState","mapEl","setMapEl","setMap","useCallback","container","Map","style","pitch","antialias","useEffect","on","addLayer","handleHover","off","layer","className","ref","params","renderingMode","camera","renderer","ready","raycaster","Raycaster","cameraTransform","bind","meterInMercatorCoordinateUnits","z","Matrix4","makeScale","multiply","setPosition","near","far","gl","PerspectiveCamera","transform","width","Scene","WebGLRenderer","canvas","getCanvas","context","autoClear","directionalLight","DirectionalLight","normalize","directionalLight2","point","mouse","Vector2","camInverseProjection","getInverse","projectionMatrix","cameraPosition","Vector3","applyMatrix4","viewDirection","clone","sub","intersects","intersectObjects","children","intersection","object","setHex","matrix","fromArray","reset","render","triggerRepaint","ev","getLayer","e","raycast","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.041ad1e2.chunk.js","sourcesContent":["//Javascript implementation of a script found at https://help.openstreetmap.org/questions/747/given-a-latlon-how-do-i-find-the-precise-position-on-the-tile\n\nimport mapboxgl, {\n  LngLat,\n  MapboxEvent,\n  MercatorCoordinate,\n} from \"mapbox-gl\"\nimport Protobuf from \"pbf\"\nimport { CylinderGeometry, MeshPhongMaterial, Mesh } from \"three\"\nimport { Layer } from \"./layer\"\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst parser = require(\"@mapbox/vector-tile\")\n//input object includes lat, lon, and zoom level.\n\nexport function getTileCoords(\n  lat: number,\n  lng: number,\n  zoom: number\n): { x: number; y: number } {\n  const MinLatitude = -85.05112878,\n    MaxLatitude = 85.05112878,\n    MinLongitude = -180,\n    MaxLongitude = 180\n\n  const latitude = clip(lat, MinLatitude, MaxLatitude)\n  const longitude = clip(lng, MinLongitude, MaxLongitude)\n\n  const x = Math.trunc(Math.pow(2, zoom) * ((longitude + 180) / 360))\n  const y = Math.trunc(\n    Math.pow(2, zoom - 1) *\n      (1 -\n        Math.log(\n          Math.tan((latitude * Math.PI) / 180) +\n            1 / Math.cos((latitude * Math.PI) / 180)\n        ) /\n          Math.PI)\n  )\n\n  return { x, y }\n\n  function clip(input: number, minValue: number, maxValue: number) {\n    return Math.min(Math.max(input, minValue), maxValue)\n  }\n}\n\nexport function loadTiles(this: Layer, event: MapboxEvent): void {\n  const center: LngLat = event.target.getCenter()\n  const zoom = Math.trunc(event.target.getZoom())\n  const { x, y } = getTileCoords(center.lat, center.lng, zoom)\n\n  console.log(\"ZOOM\", x, y, zoom, this.map)\n\n  if (zoom >= 13 && zoom < 16) {\n    if (!this.state.tilesLoaded.includes(`${x}-${y}-${zoom}`)) {\n      this.state.tilesLoaded.push(`${x}-${y}-${zoom}`)\n\n      fetch(\n        `https://api.mapbox.com/v4/mapbox.mapbox-streets-v8/${Math.floor(\n          zoom\n        )}/${Math.floor(x)}/${Math.floor(y)}.mvt?access_token=${\n          mapboxgl.accessToken\n        }`\n      )\n        .then(async (res) => {\n          if (res.ok) {\n            const data = await res.arrayBuffer()\n            const tile = new parser.VectorTile(new Protobuf(data))\n\n            this.state.buildings = this.state.buildings.concat(\n              new Array(tile.layers.building.length)\n                .fill(null)\n                .map((el, index) => {\n                  return tile.layers.building\n                    .feature(index)\n                    .toGeoJSON(x, y, zoom)\n                })\n            )\n\n            drawBuilings.apply(this)\n\n            console.log(\n              \"Tile buildings\",\n              new Array(tile.layers.building.length)\n                .fill(null)\n                .map((el, index) => {\n                  return tile.layers.building\n                    .feature(index)\n                    .toGeoJSON(x, y, zoom)\n                })\n            )\n          }\n        })\n        .catch((res) => {\n          console.log(res.message)\n          if (this.state.tilesLoaded.includes(`${x}-${y}-${zoom}`)) {\n            this.state.tilesLoaded.filter(\n              (tile) => tile !== `${x}-${y}-${zoom}`\n            )\n          }\n        })\n    }\n  }\n}\n\nfunction drawBuilings(this: Layer) {\n  this.state.buildings.forEach((feature, index) => {\n    if (\n      feature &&\n      feature.properties &&\n      feature.properties.type === \"building\" &&\n      !feature.drawn\n    ) {\n      let lnglat: null | [number, number]\n\n      switch (feature.geometry.type) {\n        // get only polygons and multipolygons coords\n        case \"Polygon\":\n          lnglat = [\n            feature.geometry.coordinates[0][0][0],\n            feature.geometry.coordinates[0][0][1],\n          ]\n          break\n        case \"MultiPolygon\":\n          lnglat = [\n            feature.geometry.coordinates[0][0][0][0],\n            feature.geometry.coordinates[0][0][0][1],\n          ]\n          break\n        default:\n          lnglat = null\n      }\n\n      if (!lnglat) return\n\n      const pos: MercatorCoordinate = MercatorCoordinate.fromLngLat(lnglat)\n\n      // compute the offset from origin in meters\n      const mercatorOffset = {\n        x: (pos.x - this.origin.x) / this.scale,\n        y: (pos.y - this.origin.y) / this.scale,\n      }\n      console.log(\"height\", feature.properties.height)\n      // draw a cylinder on buildings positions\n      const geometry = new CylinderGeometry(10, 10, 3, 32)\n      const material = new MeshPhongMaterial({\n        color: 0xaaaaaa,\n        specular: \"#cccccc\",\n        emissive: \"#888888\",\n      })\n      const obj = new Mesh(geometry, material)\n\n      obj.position.set(mercatorOffset.x, mercatorOffset.y, 0)\n      obj.rotation.set(0, Math.PI / 2, Math.PI / 2)\n\n      if (this.scene) this.scene.add(obj)\n      this.state.buildings[index].drawn = true\n      this.state.buildings[index].id = obj.id\n    }\n  })\n}\n","import {\n  Map,\n  CustomLayerInterface,\n  MercatorCoordinate,\n  MapboxEvent,\n  Point,\n} from \"mapbox-gl\"\n\nimport {\n  DirectionalLight,\n  Intersection,\n  Matrix4,\n  Mesh,\n  MeshPhongMaterial,\n  Object3D,\n  PerspectiveCamera,\n  Raycaster,\n  Scene,\n  Vector2,\n  Vector3,\n  WebGLRenderer,\n} from \"three\"\nimport { loadTiles } from \"./tiles\"\n\nexport const originLat = 48.85827\nexport const originLng = 2.29448\n\ntype DrawableFeature = { drawn: boolean; id: number } & GeoJSON.Feature\nexport class Layer implements CustomLayerInterface {\n  id: string\n  renderingMode: \"2d\" | \"3d\"\n  type: \"custom\" = \"custom\"\n  map: null | any = null\n  camera: null | PerspectiveCamera = null\n  scene: null | Scene = null\n  renderer: null | WebGLRenderer = null\n  ready = false\n  state: { buildings: DrawableFeature[]; tilesLoaded: string[] }\n  loadTiles: (event: MapboxEvent) => void\n  raycaster = new Raycaster()\n  origin: MercatorCoordinate\n  scale: number\n  cameraTransform: Matrix4\n\n  constructor(params: { id: string; renderingMode: \"2d\" | \"3d\" }) {\n    const { id, renderingMode } = params\n    this.id = id\n    this.renderingMode = renderingMode\n    this.state = { buildings: [], tilesLoaded: [] }\n    this.loadTiles = loadTiles.bind(this)\n\n    this.origin = MercatorCoordinate.fromLngLat([originLng, originLat], 0)\n    this.scale = this.origin.meterInMercatorCoordinateUnits()\n\n    const { x, y, z } = this.origin\n\n    const scale = new Matrix4().makeScale(\n      this.scale,\n      this.scale,\n      -this.scale\n    )\n\n    this.cameraTransform = new Matrix4()\n      .multiply(scale)\n      .setPosition(x, y, z)\n\n    this.raycaster.near = -1\n    this.raycaster.far = 1e6\n  }\n\n  onAdd(map: Map, gl: WebGLRenderingContext): void {\n    this.map = map\n    this.camera = new PerspectiveCamera(\n      28,\n      this.map.transform.width / this.map.transform.height,\n      1,\n      1e6\n    )\n\n    this.scene = new Scene()\n    this.renderer = new WebGLRenderer({\n      canvas: map.getCanvas(),\n      context: gl,\n      antialias: true,\n    })\n\n    this.renderer.autoClear = false\n    this.map.on(\"move\", this.loadTiles)\n\n    // create two three.js lights to illuminate the model\n    const directionalLight = new DirectionalLight(0xffffff)\n    directionalLight.position.set(0, -70, 100).normalize()\n    this.scene.add(directionalLight)\n\n    const directionalLight2 = new DirectionalLight(0xffffff)\n    directionalLight2.position.set(0, 70, 100).normalize()\n    this.scene.add(directionalLight2)\n  }\n\n  raycast(point: Point): void {\n    if (this.camera && this.scene && this.map) {\n      const mouse = new Vector2()\n      // scale mouse pixel position to a percentage of the screen's width and height\n      mouse.x = (point.x / this.map.transform.width) * 2 - 1\n      mouse.y = 1 - (point.y / this.map.transform.height) * 2\n\n      const camInverseProjection = new Matrix4().getInverse(\n        this.camera.projectionMatrix\n      )\n      const cameraPosition = new Vector3().applyMatrix4(\n        camInverseProjection\n      )\n      const mousePosition = new Vector3(mouse.x, mouse.y, 1).applyMatrix4(\n        camInverseProjection\n      )\n\n      const viewDirection = mousePosition\n        .clone()\n        .sub(cameraPosition)\n        .normalize()\n\n      this.raycaster.set(cameraPosition, viewDirection)\n\n      // calculate objects intersecting the picking ray\n      const intersects = this.raycaster.intersectObjects(\n        this.scene.children,\n        true\n      )\n      intersects.forEach((intersection: Intersection) => {\n        const material = (intersection.object as Mesh)\n          .material as MeshPhongMaterial\n\n        const building = this.state.buildings.filter(\n          (building) => building.id === intersection.object.id\n        )[0]\n\n        if (building && building.properties) {\n          const height = building.properties.height\n          if (height < 10) {\n            material.color.setHex(0x0000aa)\n            material.emissive.setHex(0x000088)\n            material.specular.setHex(0x0000cc)\n          } else if (height < 100) {\n            material.color.setHex(0x00aa00)\n            material.emissive.setHex(0x008800)\n            material.specular.setHex(0x00cc00)\n          } else {\n            material.color.setHex(0xaa0000)\n            material.emissive.setHex(0x880000)\n            material.specular.setHex(0xcc0000)\n          }\n          animate(intersection.object, height)\n        }\n      })\n      if (intersects.length > 0) {\n        console.log(\"MOUSE\", intersects[0].object.id)\n      }\n    }\n  }\n\n  render(gl: WebGLRenderingContext, matrix: Array<number>): void {\n    if (!!this.map && !!this.renderer && !!this.scene && !!this.camera) {\n      // console.log(this.map.transform.mercatorMatrix, matrix)\n      this.camera.projectionMatrix = new Matrix4()\n        .fromArray(matrix)\n        .multiply(this.cameraTransform)\n\n      this.renderer.state.reset()\n      this.renderer.render(this.scene, this.camera)\n      this.map.triggerRepaint()\n    }\n  }\n}\n\nfunction animate(cylinder: Object3D, height?: number) {\n  if (height) {\n    const intervals = 30\n    const changePerInterval = height / 3 / intervals\n\n    while (cylinder.scale.y < height) {\n      cylinder.scale.y += changePerInterval\n    }\n  }\n\n  requestAnimationFrame(() => {\n    animate(cylinder)\n  })\n}\n","import React, { useCallback, useEffect, useState } from \"react\"\nimport mapboxgl, { MapboxEvent, MapMouseEvent } from \"mapbox-gl\"\nimport \"../assets/styles/tailwind.output.css\"\nimport { originLat, originLng, Layer } from \"../map/layer\"\n\nexport function App(): JSX.Element {\n  const [mapEl, setMapEl] = useState<null | mapboxgl.Map>(null)\n\n  const setMap = useCallback(\n    (container) => {\n      if (container && !mapEl) {\n        const map = new mapboxgl.Map({\n          container,\n          style: \"mapbox://styles/mapbox/streets-v11\",\n          zoom: 14,\n          center: [originLng, originLat],\n          pitch: 40,\n          antialias: true,\n        })\n        setMapEl(map)\n      }\n    },\n    [mapEl]\n  )\n\n  useEffect(() => {\n    if (mapEl) {\n      mapEl.on(\"load\", addLayer)\n      mapEl.on(\"mousemove\", handleHover)\n\n      return () => {\n        mapEl.off(\"load\", addLayer)\n        mapEl.off(\"move\", layer.loadTiles)\n        mapEl.off(\"mousemove\", handleHover)\n      }\n    }\n  }, [mapEl])\n\n  return (\n    <div className=\"p-8 pb-12 h-screen\">\n      <div className=\"h-full\" ref={setMap} />\n    </div>\n  )\n}\n\nconst layer = new Layer({ id: \"custom_buildings\", renderingMode: \"3d\" })\n\nfunction addLayer(ev: MapboxEvent): void {\n  console.log(\"Styles\", ev)\n  const map = ev.target\n  if (!map.getLayer(\"custom_buildings\")) {\n    map.addLayer(layer)\n  }\n}\n\nfunction handleHover(e: MapMouseEvent) {\n  layer.raycast(e.point)\n}\n","import { ReportHandler } from \"web-vitals\"\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(\n      ({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n        getCLS(onPerfEntry)\n        getFID(onPerfEntry)\n        getFCP(onPerfEntry)\n        getLCP(onPerfEntry)\n        getTTFB(onPerfEntry)\n      }\n    )\n  }\n}\n\nexport default reportWebVitals\n","import React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport \"./assets/styles/index.css\"\nimport { App } from \"./components/App\"\nimport reportWebVitals from \"./reportWebVitals\"\nimport mapboxgl from \"mapbox-gl\"\n\nmapboxgl.accessToken =\n  \"pk.eyJ1Ijoicm9tY2hhbWJlIiwiYSI6ImNraG42MnNmODA5Ymoyd2s4bGtocnR6MWcifQ.BUHBlSsIxk8pGk12tnqSUQ\"\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}